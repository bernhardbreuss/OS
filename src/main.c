/*
 * main.c
 * For playing with the MMU
 */
#include <inttypes.h>
#include "service/logger/logger.h"
#include "hal/generic/timer/gptimer.h"
#include <stdio.h>

typedef volatile unsigned int* address;

/*asm("\t .bss masterTableAddress, 4");
asm("\t .global masterTableAddress");
asm("_masterTableAddress .field _masterTableAddress, 32");

extern volatile unsigned int* _masterTableAddress;

void enableMMU(void) {
	asm("\t MRC p15, #0, r1, c1, c0, #0");
	// MRC Move to ARM register from coprocessor (CP15 register to ARM register)
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first  coprocessor source register (c1 ist das Control Register des coprocessor; sihe S. 153 cortexA8.pdf)
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	asm("\t ORR r1, r1, #0x1");
	// ORR Logical OR
	// r1	is the destination register
	// r1	is the register holding the first operand
	// #0x1	is a flexible second operand (hier einfach hex 1)

	asm("\t MCR p15, #0, r1, c1, c0, #0");
	// MCR Move to coprocessor from ARM registers
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first coprocessor source register
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	// Kurz
}

void setTranslationTableBase(void) {
	asm("\t LDR r0, _masterTableAddress");
    asm("\t LDR r0, [r0]\n");
	asm("\t MCR p15, #0, r0, c2, c0, #0");
}*/

#pragma SWI_ALIAS(make_swi, 47);
void make_swi(unsigned int foo, char* bar);

#pragma INTERRUPT(udef_handler, UDEF);
//#pragma TASK(data_abort);
interrupt void udef_handler() {
	int i = 0;
	i += 2;
	//logger_error("KERNEL PANIC: data abort");
}

//#pragma TASK(swi_handler);
#pragma INTERRUPT(swi_handler,SWI);
interrupt void swi_handler(unsigned int foo, char* bar) {
	/*
	 * Save return address (R14) on the stack (later this should be saved in the PCB).
	 * As the arguments (R0 = foo, R1 = bar) have to be the top most values of the stack,
	 * they are also saved (again) on the stack.
	 * The stack looks afterwards like:
	 * SP -->	R0
	 * 			R1
	 * 			R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t STMFD R13!, {R0-R1, R14}");

	//logger_debug("Hi! This is the SWI-Handler. You have told me: %u: %s", foo, bar);
	logger_logmode();

	/* Working for setting mode after interrupt:
	 * asm("\t MRS R12, SPSR");
	asm("\t ORR R12, R12, #0x1F");
	asm("\t MSR SPSR, R12");*/

	//return 4711;

	/*
	 * Remove the self pushed arguments from the stack.
	 * As one register has 32 bit (4 byte), the stack pointer (R13) has to be changed by 8 byte
	 * (2 arguments * 4 byte).
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 	SP -->	R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t ADD R13, R13, #8");

	/*
	 * Loads the next value from the stack, which is the return address saved at the beginning of this method
	 * (later this value should come from PCB or something similar). The value will be loaded into the R14
	 * (which usually holds the return address). The code generated by the compiler includes then the
	 * command MOVS	PC, R14, which is the return out of the interrupt;
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 			R14
	 * 	SP -->	R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t LDMFD R13!, {R14}");
}

#pragma INTERRUPT(pabt_handler, PABT);
//#pragma TASK(pabt_handler);
interrupt void pabt_handler() {
	int i = 0;
	i += 2;
	//logger_error("KERNEL PANIC: data abort");
}

#pragma INTERRUPT(dabt_handler, DABT);
//#pragma TASK(dabt_handler);
interrupt void dabt_handler() {
	int i = 0;
	i += 2;
	//logger_error("KERNEL PANIC: data abort");
}

timer_t main_timer;
unsigned volatile int irq_number = 0;

void clear_pending_interrupts(timer_t);

#pragma INTERRUPT(irq_handler, IRQ);
//#pragma TASK(irq_handler);
interrupt void irq_handler() {
	if (++irq_number % 100000 == 0) {
		logger_error("Interrupt number: %u", irq_number);
	}

	/* clear all pending interrupts */
	clear_pending_interrupts(main_timer);
	*((unsigned int*)0x48200048) = 0x1; /* INTCPS_CONTROL s. 1083 */
}

void main(void) {
	logger_init();
	logger_debug("\r\n\r\nSystem init...");
	logger_logmode();


	/* activate the specific interrupt (interrupt mask) */
	address mpuintc_mir_clearn_1 = (unsigned int*)(0x48200000+0x88+((38/32)*0x20));
	unsigned int gp2_irq = (1 << (38 % 32));
	*(mpuintc_mir_clearn_1) = gp2_irq;

	main_timer = gptimer_init_ms();
	gptimer_start(main_timer);

    while (1) ;
}
