/*
 * main.c
 * For playing with the MMU
 */
#include <inttypes.h>
#include "service/logger/logger.h"
#include "hal/omap3530_timer.h"

/*asm("\t .bss masterTableAddress, 4");
asm("\t .global masterTableAddress");
asm("_masterTableAddress .field _masterTableAddress, 32");

extern volatile unsigned int* _masterTableAddress;

void enableMMU(void) {
	asm("\t MRC p15, #0, r1, c1, c0, #0");
	// MRC Move to ARM register from coprocessor (CP15 register to ARM register)
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first  coprocessor source register (c1 ist das Control Register des coprocessor; sihe S. 153 cortexA8.pdf)
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	asm("\t ORR r1, r1, #0x1");
	// ORR Logical OR
	// r1	is the destination register
	// r1	is the register holding the first operand
	// #0x1	is a flexible second operand (hier einfach hex 1)

	asm("\t MCR p15, #0, r1, c1, c0, #0");
	// MCR Move to coprocessor from ARM registers
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first coprocessor source register
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	// Kurz
}

void setTranslationTableBase(void) {
	asm("\t LDR r0, _masterTableAddress");
    asm("\t LDR r0, [r0]\n");
	asm("\t MCR p15, #0, r0, c2, c0, #0");
}*/

#pragma SWI_ALIAS(make_swi, 47);
void make_swi(unsigned int foo, char* bar);

#pragma INTERRUPT(udef_handler, UDEF);
interrupt void udef_handler() {
	int i = 0;
	i += 2;
	logger_error("KERNEL PANIC: udef handler.");
}


#pragma INTERRUPT(swi_handler,SWI);
interrupt void swi_handler(unsigned int foo, char* bar) {
	/*
	 * Save return address (R14) on the stack (later this should be saved in the PCB).
	 * As the arguments (R0 = foo, R1 = bar) have to be the top most values of the stack,
	 * they are also saved (again) on the stack.
	 * The stack looks afterwards like:
	 * SP -->	R0
	 * 			R1
	 * 			R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t STMFD R13!, {R0-R1, R14}");

	//logger_debug("Hi! This is the SWI-Handler. You have told me: %u: %s", foo, bar);
	logger_logmode();

	/* Working for setting mode after interrupt:
	 * asm("\t MRS R12, SPSR");
	asm("\t ORR R12, R12, #0x1F");
	asm("\t MSR SPSR, R12");*/

	//return 4711;

	/*
	 * Remove the self pushed arguments from the stack.
	 * As one register has 32 bit (4 byte), the stack pointer (R13) has to be changed by 8 byte
	 * (2 arguments * 4 byte).
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 	SP -->	R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t ADD R13, R13, #8");

	/*
	 * Loads the next value from the stack, which is the return address saved at the beginning of this method
	 * (later this value should come from PCB or something similar). The value will be loaded into the R14
	 * (which usually holds the return address). The code generated by the compiler includes then the
	 * command MOVS	PC, R14, which is the return out of the interrupt;
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 			R14
	 * 	SP -->	R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t LDMFD R13!, {R14}");
}

#pragma INTERRUPT(pabt_handler, PABT);
interrupt void pabt_handler() {
	int i = 0;
	i += 2;
	logger_error("KERNLE PANIC: Prefetch abort.");
}

#pragma INTERRUPT(dabt_handler, DABT);
interrupt void dabt_handler() {
	int i = 0;
	i += 2;
	logger_error("KERNEL PANIC: data abort");
}


#pragma INTERRUPT(irq_handler, IRQ);
interrupt void irq_handler() {
	asm("\t STMFD R13!, {R14}");

	logger_error("timer interrupt occurred ....");

	asm("\t LDMFD R13!, {R14}");
}

void main(void) {
	logger_init();
	logger_debug("\r\n\r\nSystem init...");
	logger_logmode();

    //asm("\t CPS 0x10"); // enter User Mode
	logger_logmode();

    make_swi(4712, "foobar");
    //logger_debug("swi returned: %u", c);
	logger_logmode();

	make_swi(0x4712, "hugo");

    logger_debug("I'm done, bye");
	logger_logmode();
	
	unsigned volatile int *tier_2 = (unsigned int*) 0x4903201C;
	unsigned int tier_capture_bit 	= 0x4;
	unsigned int tier_overflow_bit 	= 0x2;
	unsigned int tier_match_bit 	= 0x1;

	unsigned volatile int *tclr_2 = (unsigned int*) 0x49032024;
	unsigned int tclr_start_bit 		= 0x1;
	unsigned int tclr_autoreload_bit	= 0x2;
	unsigned int tclr_trigger_both 		= 0x800;	/*overflow and match*/
	unsigned int tclr_compare_bit 		= 0x40;
	
	unsigned volatile int *tcrr_2 = (unsigned int*) 0x49032028;
	unsigned volatile int *tldr_2 = (unsigned int*) 0x4903202C;
	unsigned volatile int *tmar_2 = (unsigned int*) 0x49032038;

    logger_debug("Done with SW interrupts, up next timer interrupts ....");

    logger_log_register("Tier register current status: %s", tier_2);
    logger_log_register("Tclr register current status: %s", tclr_2);
    logger_log_register("Tcrr register current status: %s", tcrr_2);
    logger_log_register("Tldr register current status: %s", tldr_2);
    logger_log_register("Tmar regiser current status: %s", tmar_2);
    logger_debug("--------------------------------------------------------------");

	/* disable all interrupt events */
	*(tier_2) &= ~(tier_capture_bit | tier_overflow_bit | tier_match_bit);
	logger_log_register("Tier disabled all interrupts: %s", tier_2);

	/* stop the timer if already running */
	logger_debug("Stop timer with Tclr if running - bit 1");
	*(tclr_2) &= ~tclr_start_bit;
	logger_log_register("Tclr now: %s", tclr_2);
	logger_debug("Enable Tclr Autoreload mode (bit 2) and set set trigger mode to both (overflow and match) (bit 12)");
	*(tclr_2) |= (tclr_autoreload_bit | tclr_trigger_both);
	logger_log_register("Tclr now: %s", tclr_2);
	logger_debug("Tclr enable compare enable - bit 7");
	*(tclr_2) |= tclr_compare_bit;
	logger_log_register("Tclr now: %s", tclr_2);

	*(tcrr_2) = 0x0;
	*(tldr_2) = 0x0;
	logger_log_register("Tcrr (counter) registerd cleared: %s", tcrr_2);
	logger_log_register("Tldr (load) registerd cleared: %s", tldr_2);

	/* set timer match register */
	logger_debug("Set tmar register to 3200000 (bin val: 1100001101010000000000)");
	*(tmar_2) = 3200000;
	logger_log_register("Tmar now: %s", tmar_2);

	/* enable the match interrupt event */
	logger_debug("Set Tier match interrupt flag ...");
	*(tier_2) |= 0x1;
	logger_log_register("Tier register now: %s", tier_2);

	/* start the timer */
    logger_debug("Timer setup complete .... start it");
    *(tclr_2) |= tclr_start_bit;
    logger_log_register("Tclr with bit 1 set to 1, timer should run now: %s", tclr_2);

    /* TODO: register INTCPS handler for this timer interrupt and get it to work */
    unsigned volatile int mpu_intc = 0x48200000;

    while (1) ;
}
