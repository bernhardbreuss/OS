/*
 * main.c
 * For playing with the MMU
 */
#include <inttypes.h>
#include "service/logger/logger.h"
#include "hal/omap3530_timer.h"

typedef volatile unsigned int* address;

/*asm("\t .bss masterTableAddress, 4");
asm("\t .global masterTableAddress");
asm("_masterTableAddress .field _masterTableAddress, 32");

extern volatile unsigned int* _masterTableAddress;

void enableMMU(void) {
	asm("\t MRC p15, #0, r1, c1, c0, #0");
	// MRC Move to ARM register from coprocessor (CP15 register to ARM register)
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first  coprocessor source register (c1 ist das Control Register des coprocessor; sihe S. 153 cortexA8.pdf)
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	asm("\t ORR r1, r1, #0x1");
	// ORR Logical OR
	// r1	is the destination register
	// r1	is the register holding the first operand
	// #0x1	is a flexible second operand (hier einfach hex 1)

	asm("\t MCR p15, #0, r1, c1, c0, #0");
	// MCR Move to coprocessor from ARM registers
	// p15	ist der coprocessor
	// #0	is a coprocessor-specific opcode
	// r1	is the ARM destination register
	// c1	first coprocessor source register
	// c0	second coprocessor source register
	// #0	is an optional coprocessor-specific opcode

	// Kurz
}

void setTranslationTableBase(void) {
	asm("\t LDR r0, _masterTableAddress");
    asm("\t LDR r0, [r0]\n");
	asm("\t MCR p15, #0, r0, c2, c0, #0");
}*/

#pragma SWI_ALIAS(make_swi, 47);
void make_swi(unsigned int foo, char* bar);

#pragma TASK(swi_handler);
#pragma INTERRUPT(swi_handler,SWI);
extern void swi_handler(unsigned int foo, char* bar) {
	/*
	 * Save return address (R14) on the stack (later this should be saved in the PCB).
	 * As the arguments (R0 = foo, R1 = bar) have to be the top most values of the stack,
	 * they are also saved (again) on the stack.
	 * The stack looks afterwards like:
	 * SP -->	R0
	 * 			R1
	 * 			R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t STMFD R13!, {R0-R1, R14}");

	logger_debug("Hi! This is the SWI-Handler. You have told me: %u: %s", foo, bar);
	logger_logmode();

	/* Working for setting mode after interrupt:
	 * asm("\t MRS R12, SPSR");
	asm("\t ORR R12, R12, #0x1F");
	asm("\t MSR SPSR, R12");*/

	//return 4711;

	/*
	 * Remove the self pushed arguments from the stack.
	 * As one register has 32 bit (4 byte), the stack pointer (R13) has to be changed by 8 byte
	 * (2 arguments * 4 byte).
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 	SP -->	R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t ADD R13, R13, #8");

	/*
	 * Loads the next value from the stack, which is the return address saved at the beginning of this method
	 * (later this value should come from PCB or something similar). The value will be loaded into the R14
	 * (which usually holds the return address). The code generated by the compiler includes then the
	 * command MOVS	PC, R14, which is the return out of the interrupt;
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 			R14
	 * 	SP -->	R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t LDMFD R13!, {R14}");
}

#pragma INTERRUPT(irq_handler, IRQ)
void irq_handler() {
	logger_error("timer interrupt occurred ....");
}

void main(void) {
	logger_init();
	logger_debug("\r\n\r\nSystem init...");
	logger_logmode();

    asm("\t CPS 0x10"); // enter User Mode
	logger_logmode();

    make_swi(4712, "foobar");
    //logger_debug("swi returned: %u", c);
	logger_logmode();

	make_swi(0x4712, "hugo");

    logger_debug("I'm done, bye");
	logger_logmode();
	
	
    logger_debug("Done with SW interrupts, up next timer interrupts ....");

	address tier = (address)((int)GPTIMER1_BASE + GPTIMER_BASE_OFFSET_TIER);
	address tclr = (address)((int)GPTIMER1_BASE + GPTIMER_BASE_OFFSET_TCLR);
	address tcrr = (address)((int)GPTIMER1_BASE + GPTIMER_BASE_OFFSET_TCRR);
	address tldr = (address)((int)GPTIMER1_BASE + GPTIMER_BASE_OFFSET_TLDR);
	address tmar = (address)((int)GPTIMER1_BASE + GPTIMER_BASE_OFFSET_TMAR);

	/* disable all interrupt events */
	*(tier) &= 0x0;
	/* stop the timer if running already */
	*(tclr) &= ~0x1;
	/* reset the counter register and load register*/
	*(tcrr) &= 0x0;
	*(tldr) &= 0x0;

	/* set timer match register */
	*(tmar) = 32000;

	/* enable compare and auto reload modes */
	*(tclr) |= (1 < GPTIMER_TCLR_COMPARE_ENABLE_OFFSET);
	*(tclr) |= (1 < GPTIMER_TCLR_AUTORELOAD_MODE_OFFSET);

	/* enable the match interrupt event */
	*(tier) |= (1 < GPTIMER_TISR_MATCH_FLAG_OFFSET);

	/* start the timer */
	*(tclr) |= (1 < GPTIMER_TCLR_START_STOP_CONTROL_OFFSET);

    while (1) ;
}
