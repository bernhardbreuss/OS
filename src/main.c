/*
 * main.c
 */

#include <inttypes.h>
#include "service/logger/logger.h"
#include "hal/generic/timer/gptimer.h"
#include "kernel/process.h"
#include "kernel/process_manager.h"
#include <stdio.h>

#pragma SWI_ALIAS(make_swi, 47);
void make_swi(unsigned int foo, char* bar);

#pragma INTERRUPT(udef_handler, UDEF);
interrupt void udef_handler() {
	int i = 0;
	i += 2;	logger_error("KERNEL PANIC: udef handler.");
}


#pragma INTERRUPT(swi_handler,SWI);
interrupt void swi_handler(unsigned int foo, char* bar) {
	/*
	 * Save return address (R14) on the stack (later this should be saved in the PCB).
	 * As the arguments (R0 = foo, R1 = bar) have to be the top most values of the stack,
	 * they are also saved (again) on the stack.
	 * The stack looks afterwards like:
	 * SP -->	R0
	 * 			R1
	 * 			R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t STMFD R13!, {R0-R1, R14}");

	//logger_debug("Hi! This is the SWI-Handler. You have told me: %u: %s", foo, bar);
	logger_logmode();

	/* Working for setting mode after interrupt:
	 * asm("\t MRS R12, SPSR");
	asm("\t ORR R12, R12, #0x1F");
	asm("\t MSR SPSR, R12");*/

	//return 4711;

	/*
	 * Remove the self pushed arguments from the stack.
	 * As one register has 32 bit (4 byte), the stack pointer (R13) has to be changed by 8 byte
	 * (2 arguments * 4 byte).
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 	SP -->	R14
	 * 			R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t ADD R13, R13, #8");

	/*
	 * Loads the next value from the stack, which is the return address saved at the beginning of this method
	 * (later this value should come from PCB or something similar). The value will be loaded into the R14
	 * (which usually holds the return address). The code generated by the compiler includes then the
	 * command MOVS	PC, R14, which is the return out of the interrupt;
	 * The stack looks afterwards like:
	 * 			R0
	 * 			R1
	 * 			R14
	 * 	SP -->	R0 (added from compiler, don't know how to avoid this stack push)
	 * 			R1 (added from compiler, don't know how to avoid this stack push)
	 */
	asm("\t LDMFD R13!, {R14}");
}

#pragma INTERRUPT(pabt_handler, PABT);
interrupt void pabt_handler() {
	int i = 0;
	i += 2;
	logger_error("KERNLE PANIC: Prefetch abort.");
}

#pragma INTERRUPT(dabt_handler, DABT);
interrupt void dabt_handler() {
	int i = 0;
	i += 2;
	logger_error("KERNEL PANIC: data abort");
}

timer_t main_timer;

void clear_pending_interrupts(timer_t);

ProcessManager_t processManager;
ProcessId_t currentProcessId;

#define LED0_PIN			(1 << 21)
#define LED1_PIN			(1 << 22)
#define GPIO5_OUT			(unsigned int*) 0x4905603C

int led0(void) {
	int i;
	logger_debug("Led 0");
	while (1) {
		for(i = 0; i < 450000; i++) ;
		*(GPIO5_OUT) ^= LED0_PIN;
	}
}

int led1(void) {
	int i;
	logger_debug("Led 1");
	while (1) {
		for(i = 0; i < 900000; i++);
		*(GPIO5_OUT) ^= LED1_PIN;
	}
}

int idle_task(void) {
	while (1) ; /* TODO: look manual for HALT command or similar to reduce power consumption */
}

void turnoff_rgb(void) {
	/* set mode to 4 (GPIO) see p. ~787 of omap35x.pdf */
	unsigned int* CONTROL_PADCONF_UART2_CTS = (unsigned int*)0x48002174; /* GPIO144 15:0 GPIO145 16:32 */
	unsigned int* CONTROL_PADCONF_UART2_TX = (unsigned int*)0x48002178; /* GPIO146 15:0 */
	*(CONTROL_PADCONF_UART2_CTS) = (4 << 16) | 4;
	*(CONTROL_PADCONF_UART2_TX) &= ~7;
	*(CONTROL_PADCONF_UART2_TX) |= 4;

	/* turn off rgb led on dmx interface
	 *  GPIO 144, 146, 145 --> GPIO 5 */
	unsigned int* GPIO5_OE = (unsigned int*)0x49056034;
	unsigned int* GPIO5_DATAOUT = (unsigned int*)0x4905603C;
	unsigned int rgb = (1 << (144 % 32)) | (1 << (146 % 32)) | (1 << (145 % 32));
	*(GPIO5_OE) &= ~rgb;
	*(GPIO5_DATAOUT) &= ~rgb;
}

void main(void) {
	logger_init();
	logger_debug("\r\n\r\nSystem init...");
	logger_logmode();

	/* init led stuff */
	turnoff_rgb();
	#define GPIO5_DIR  			(unsigned int*) 0x49056094
	*(GPIO5_DIR) |= LED0_PIN | LED1_PIN;

	process_manager_init(&processManager);

	Process_t process1;
	process1.func = &led0;
	currentProcessId = process_manager_add_process(&processManager, &process1);

	Process_t process2;
	process2.func = &led1;
	process_manager_add_process(&processManager, &process2);

	/* idle task */
	Process_t idle_process;
	idle_process.func = &idle_task;
	process_manager_add_process(&processManager, &idle_process);

	/* activate the specific interrupt (interrupt mask) */
	unsigned int* mpuintc_mir_clearn_1 = (unsigned int*)(0x48200000+0x88+((38/32)*0x20));
	unsigned int gp2_irq = (1 << (38 % 32));
	*(mpuintc_mir_clearn_1) = gp2_irq;

	main_timer = gptimer_init_ms();
	gptimer_start(main_timer);

	processManager.currentProcessId = idle_process.pid;
	idle_task();
}

void edis_timerstuff(void) {
	make_swi(0x4712, "hugo");

    logger_debug("I'm done, bye");
	logger_logmode();
	
	unsigned volatile int *tier_2 = (unsigned int*) 0x4903201C;
	unsigned int tier_capture_bit 	= 0x4;
	unsigned int tier_overflow_bit 	= 0x2;
	unsigned int tier_match_bit 	= 0x1;

	unsigned volatile int *tclr_2 = (unsigned int*) 0x49032024;
	unsigned int tclr_start_bit 		= 0x1;
	unsigned int tclr_autoreload_bit	= 0x2;
	unsigned int tclr_trigger_both 		= 0x800;	/*overflow and match*/
	unsigned int tclr_compare_bit 		= 0x40;
	
	unsigned volatile int *tcrr_2 = (unsigned int*) 0x49032028;
	unsigned volatile int *tldr_2 = (unsigned int*) 0x4903202C;
	unsigned volatile int *tmar_2 = (unsigned int*) 0x49032038;

    logger_debug("Done with SW interrupts, up next timer interrupts ....");

    logger_log_register("Tier register current status: %s", tier_2);
    logger_log_register("Tclr register current status: %s", tclr_2);
    logger_log_register("Tcrr register current status: %s", tcrr_2);
    logger_log_register("Tldr register current status: %s", tldr_2);
    logger_log_register("Tmar regiser current status: %s", tmar_2);
    logger_debug("--------------------------------------------------------------");

	/* disable all interrupt events */
	*(tier_2) &= ~(tier_capture_bit | tier_overflow_bit | tier_match_bit);
	logger_log_register("Tier disabled all interrupts: %s", tier_2);

	/* stop the timer if already running */
	logger_debug("Stop timer with Tclr if running - bit 1");
	*(tclr_2) &= ~tclr_start_bit;
	logger_log_register("Tclr now: %s", tclr_2);
	logger_debug("Enable Tclr Autoreload mode (bit 2) and set set trigger mode to both (overflow and match) (bit 12)");
	*(tclr_2) |= (tclr_autoreload_bit | tclr_trigger_both);
	logger_log_register("Tclr now: %s", tclr_2);
	logger_debug("Tclr enable compare enable - bit 7");
	*(tclr_2) |= tclr_compare_bit;
	logger_log_register("Tclr now: %s", tclr_2);

	*(tcrr_2) = 0x0;
	*(tldr_2) = 0x0;
	logger_log_register("Tcrr (counter) registerd cleared: %s", tcrr_2);
	logger_log_register("Tldr (load) registerd cleared: %s", tldr_2);

	/* set timer match register */
	logger_debug("Set tmar register to 3200000 (bin val: 1100001101010000000000)");
	*(tmar_2) = 3200000;
	logger_log_register("Tmar now: %s", tmar_2);

	/* enable the match interrupt event */
	logger_debug("Set Tier match interrupt flag ...");
	*(tier_2) |= 0x1;
	logger_log_register("Tier register now: %s", tier_2);

	/* start the timer */
    logger_debug("Timer setup complete .... start it");
    *(tclr_2) |= tclr_start_bit;
    logger_log_register("Tclr with bit 1 set to 1, timer should run now: %s", tclr_2);

    /* TODO: register INTCPS handler for this timer interrupt and get it to work */
    unsigned volatile int mpu_intc = 0x48200000;
}
